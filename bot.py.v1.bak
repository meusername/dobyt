import json
import logging
import os
import time
from datetime import datetime, timedelta
from decimal import Decimal

import ccxt
import psycopg2
from dotenv import load_dotenv

# –ù–∞—Å—Ç—Ä–æ–π–∫–∞ –ª–æ–≥–∏—Ä–æ–≤–∞–Ω–∏—è
logging.basicConfig(
    level=logging.INFO,
    format="%(asctime)s - %(levelname)s - %(message)s",
    datefmt="%Y-%m-%d %H:%M:%S",
)
logger = logging.getLogger(__name__)

load_dotenv()


class BybitSpotBot:
    def __init__(self):
        self.exchange = ccxt.bybit(
            {
                "apiKey": os.getenv("BYBIT_API_KEY"),
                "secret": os.getenv("BYBIT_API_SECRET"),
                "enableRateLimit": True,
                "sandbox": False,
                "rateLimit": 100,
            }
        )

        try:
            markets = self.exchange.load_markets()
            logger.info(f"‚úÖ –£—Å–ø–µ—à–Ω–æ –ø–æ–¥–∫–ª—é—á–µ–Ω–æ –∫ Bybit. –î–æ—Å—Ç—É–ø–Ω–æ –ø–∞—Ä: {len(markets)}")

            # –í–û–°–°–¢–ê–ù–ê–í–õ–ò–í–ê–ï–ú –î–ò–ê–ì–ù–û–°–¢–ò–ö–£ –†–´–ù–ö–û–í
            spot_usdt_pairs = [
                sym
                for sym in markets.keys()
                if markets[sym].get("spot") and "USDT" in sym
            ]
            logger.info(f"üîç –ù–∞–π–¥–µ–Ω–æ —Å–ø–æ—Ç–æ–≤—ã—Ö USDT –ø–∞—Ä: {len(spot_usdt_pairs)}")
            if spot_usdt_pairs:
                logger.info("üìä –ü—Ä–∏–º–µ—Ä—ã —Å–ø–æ—Ç–æ–≤—ã—Ö –ø–∞—Ä:")
                for symbol in spot_usdt_pairs[:5]:
                    logger.info(f"   {symbol}")

        except Exception as e:
            logger.error(f"‚ùå –û—à–∏–±–∫–∞ –ø–æ–¥–∫–ª—é—á–µ–Ω–∏—è –∫ Bybit: {e}")
            raise

        # –ö–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—è
        self.total_capital = Decimal("50")
        self.min_order = Decimal("5")
        self.commission = Decimal("0.001")
        self.max_positions = 3
        self.position_size = Decimal("12")
        self.reserve_cash = Decimal("8")

        # –ó–∞—â–∏—Ç–Ω—ã–µ –ø–∞—Ä–∞–º–µ—Ç—Ä—ã
        self.stop_loss = Decimal("0.98")
        self.take_profit = Decimal("1.03")
        self.trailing_stop = Decimal("0.985")
        self.max_hold_hours = 6

        # –ü–∞—Ä–∞–º–µ—Ç—Ä—ã –ë–î
        self.db_config = {
            "host": os.getenv("DB_HOST", "postgres"),
            "database": os.getenv("DB_NAME", "bybit_bot"),
            "user": os.getenv("DB_USER", "trader"),
            "password": os.getenv("DB_PASSWORD", "trading_password"),
            "port": os.getenv("DB_PORT", "5432"),
        }

        # –ö—ç—à–∏—Ä–æ–≤–∞–Ω–∏–µ –¥–∞–Ω–Ω—ã—Ö –¥–ª—è –æ–ø—Ç–∏–º–∏–∑–∞—Ü–∏–∏
        self.last_tickers_update = None
        self.cached_tickers = {}
        self.tickers_cache_ttl = 10
        self.last_status_log = 0
        self.status_log_interval = 60  # –†–∞–∑ –≤ –º–∏–Ω—É—Ç—É –≤—ã–≤–æ–¥–∏–º —Å—Ç–∞—Ç—É—Å

        self.db_conn = self.init_db()

    def init_db(self):
        """–ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è PostgreSQL —Å–æ–µ–¥–∏–Ω–µ–Ω–∏—è"""
        try:
            conn = psycopg2.connect(**self.db_config)
            with conn.cursor() as cur:
                cur.execute("""
                    CREATE TABLE IF NOT EXISTS portfolio (
                        id SERIAL PRIMARY KEY,
                        symbol VARCHAR(50) NOT NULL,
                        quantity DECIMAL(20,8) NOT NULL,
                        entry_price DECIMAL(20,8) NOT NULL,
                        current_price DECIMAL(20,8),
                        entry_time TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                        profit_loss DECIMAL(10,4),
                        status VARCHAR(10) DEFAULT 'active'
                    )
                """)
                cur.execute("""
                    CREATE TABLE IF NOT EXISTS transactions (
                        id SERIAL PRIMARY KEY,
                        symbol VARCHAR(50) NOT NULL,
                        side VARCHAR(10) NOT NULL,
                        quantity DECIMAL(20,8) NOT NULL,
                        price DECIMAL(20,8) NOT NULL,
                        fee DECIMAL(20,8),
                        total DECIMAL(20,8) NOT NULL,
                        timestamp TIMESTAMP DEFAULT CURRENT_TIMESTAMP
                    )
                """)
            conn.commit()
            logger.info("‚úÖ –ë–∞–∑–∞ –¥–∞–Ω–Ω—ã—Ö –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω–∞")

            # –í–û–°–°–¢–ê–ù–ê–í–õ–ò–í–ê–ï–ú –î–ò–ê–ì–ù–û–°–¢–ò–ö–£ –ü–û–†–¢–§–ï–õ–Ø –ü–†–ò –°–¢–ê–†–¢–ï
            self.log_initial_portfolio()

            return conn
        except Exception as e:
            logger.error(f"‚ùå –û—à–∏–±–∫–∞ –ø–æ–¥–∫–ª—é—á–µ–Ω–∏—è –∫ –ë–î: {e}")
            return None

    def log_initial_portfolio(self):
        """–õ–æ–≥–∏—Ä–æ–≤–∞–Ω–∏–µ –Ω–∞—á–∞–ª—å–Ω–æ–≥–æ —Å–æ—Å—Ç–æ—è–Ω–∏—è –ø–æ—Ä—Ç—Ñ–µ–ª—è"""
        try:
            portfolio = self.get_current_portfolio()
            balance = self.get_usdt_balance()

            logger.info("üìä –ù–ê–ß–ê–õ–¨–ù–û–ï –°–û–°–¢–û–Ø–ù–ò–ï –ü–û–†–¢–§–ï–õ–Ø:")
            logger.info(f"üí∞ –ë–∞–ª–∞–Ω—Å USDT: {balance}")
            logger.info(f"üì¶ –ü–æ–∑–∏—Ü–∏–π –≤ –ø–æ—Ä—Ç—Ñ–µ–ª–µ: {len(portfolio)}")

            if portfolio:
                logger.info("üîç –î–µ—Ç–∞–ª–∏ –ø–æ—Ä—Ç—Ñ–µ–ª—è:")
                total_value = Decimal("0")
                for symbol, position in portfolio.items():
                    current_price = position.get("current_price", Decimal("0"))
                    quantity = position["quantity"]
                    value = quantity * current_price
                    total_value += value
                    logger.info(
                        f"   {symbol}: {quantity} √ó {current_price} = {value:.2f} USDT"
                    )

                logger.info(f"üìà –û–±—â–∞—è —Å—Ç–æ–∏–º–æ—Å—Ç—å –ø–æ—Ä—Ç—Ñ–µ–ª—è: {total_value:.2f} USDT")
            else:
                logger.info("üí° –ü–æ—Ä—Ç—Ñ–µ–ª—å –ø—É—Å—Ç")

        except Exception as e:
            logger.error(f"‚ùå –û—à–∏–±–∫–∞ –ª–æ–≥–∏—Ä–æ–≤–∞–Ω–∏—è –Ω–∞—á–∞–ª—å–Ω–æ–≥–æ –ø–æ—Ä—Ç—Ñ–µ–ª—è: {e}")

    def get_cached_tickers(self):
        """–ü–æ–ª—É—á–µ–Ω–∏–µ —Ç–∏–∫–µ—Ä–æ–≤ —Å –∫—ç—à–∏—Ä–æ–≤–∞–Ω–∏–µ–º –∏ –ª–æ–≥–∏—Ä–æ–≤–∞–Ω–∏–µ–º –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è"""
        current_time = time.time()

        if (
            self.last_tickers_update is None
            or current_time - self.last_tickers_update > self.tickers_cache_ttl
            or not self.cached_tickers
        ):
            try:
                old_count = len(self.cached_tickers)
                self.cached_tickers = self.fetch_filtered_tickers()
                self.last_tickers_update = current_time

                # –õ–æ–≥–∏—Ä—É–µ–º –æ–±–Ω–æ–≤–ª–µ–Ω–∏–µ —Ç–∏–∫–µ—Ä–æ–≤
                new_count = len(self.cached_tickers)
                logger.debug(f"üîÑ –û–±–Ω–æ–≤–ª–µ–Ω –∫—ç—à —Ç–∏–∫–µ—Ä–æ–≤: {old_count} -> {new_count} –ø–∞—Ä")

            except Exception as e:
                logger.error(f"‚ùå –û—à–∏–±–∫–∞ –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è –∫—ç—à–∞ —Ç–∏–∫–µ—Ä–æ–≤: {e}")

        return self.cached_tickers

    def fetch_filtered_tickers(self):
        """–û–ø—Ç–∏–º–∏–∑–∏—Ä–æ–≤–∞–Ω–Ω–æ–µ –ø–æ–ª—É—á–µ–Ω–∏–µ —Ç–∏–∫–µ—Ä–æ–≤"""
        try:
            tickers = self.exchange.fetch_tickers()
            filtered = {}

            for symbol, ticker in tickers.items():
                if "/USDT:USDT" in symbol:
                    try:
                        price = (
                            Decimal(str(ticker.get("last", 0)))
                            if ticker.get("last")
                            else Decimal("0")
                        )
                        volume = (
                            Decimal(str(ticker.get("baseVolume", 0)))
                            if ticker.get("baseVolume")
                            else Decimal("0")
                        )
                        change_24h = (
                            Decimal(str(ticker.get("percentage", 0)))
                            if ticker.get("percentage")
                            else Decimal("0")
                        )

                        price_ok = price > Decimal("0.001") and price <= Decimal("20")
                        volume_ok = volume >= Decimal("5000")
                        change_ok = change_24h > Decimal("-30")

                        if price_ok and volume_ok and change_ok:
                            base_symbol = symbol.replace("/USDT:USDT", "USDT")
                            filtered[base_symbol] = {
                                "price": price,
                                "volume": volume,
                                "change_24h": change_24h,
                                "symbol": base_symbol,
                                "original_symbol": symbol,
                            }

                    except Exception as e:
                        continue

            return filtered

        except Exception as e:
            logger.error(f"‚ùå –û—à–∏–±–∫–∞ –ø–æ–ª—É—á–µ–Ω–∏—è —Ç–∏–∫–µ—Ä–æ–≤: {e}")
            return {}

    def sync_portfolio_with_exchange(self):
        """–°–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∞—Ü–∏—è –ø–æ—Ä—Ç—Ñ–µ–ª—è —Å –±–∏—Ä–∂–µ–π —Å –ª–æ–≥–∏—Ä–æ–≤–∞–Ω–∏–µ–º"""
        try:
            balance = self.exchange.fetch_balance()
            db_portfolio = self.get_current_portfolio()
            added_count = 0

            logger.debug("üîÑ –°–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∞—Ü–∏—è –ø–æ—Ä—Ç—Ñ–µ–ª—è —Å –±–∏—Ä–∂–µ–π...")

            for currency, data in balance.items():
                if currency in [
                    "free",
                    "used",
                    "total",
                    "info",
                    "timestamp",
                    "datetime",
                ]:
                    continue

                if isinstance(data, dict):
                    free_balance = Decimal(str(data.get("free", 0)))
                    if free_balance > Decimal("0.0001") and currency != "USDT":
                        symbol = f"{currency}USDT"

                        if symbol not in db_portfolio:
                            logger.info(
                                f"üì• –û–±–Ω–∞—Ä—É–∂–µ–Ω–∞ –Ω–æ–≤–∞—è –ø–æ–∑–∏—Ü–∏—è –Ω–∞ –±–∏—Ä–∂–µ: {symbol}"
                            )

                            try:
                                ticker = self.exchange.fetch_ticker(symbol)
                                current_price = (
                                    Decimal(str(ticker["last"]))
                                    if ticker.get("last")
                                    else Decimal("0")
                                )

                                if current_price > Decimal("0") and self.db_conn:
                                    with self.db_conn.cursor() as cur:
                                        cur.execute(
                                            """
                                            INSERT INTO portfolio (symbol, quantity, entry_price, current_price)
                                            VALUES (%s, %s, %s, %s)
                                            """,
                                            (
                                                symbol,
                                                float(free_balance),
                                                float(current_price),
                                                float(current_price),
                                            ),
                                        )
                                    self.db_conn.commit()
                                    logger.info(
                                        f"‚úÖ –î–æ–±–∞–≤–ª–µ–Ω–∞ –ø–æ–∑–∏—Ü–∏—è {symbol}: {free_balance} –ø–æ —Ü–µ–Ω–µ {current_price}"
                                    )
                                    added_count += 1

                            except Exception as e:
                                logger.error(f"‚ùå –û—à–∏–±–∫–∞ –¥–æ–±–∞–≤–ª–µ–Ω–∏—è {symbol}: {e}")

            if added_count > 0:
                logger.info(
                    f"‚úÖ –°–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∞—Ü–∏—è –∑–∞–≤–µ—Ä—à–µ–Ω–∞. –î–æ–±–∞–≤–ª–µ–Ω–æ –ø–æ–∑–∏—Ü–∏–π: {added_count}"
                )
            else:
                logger.debug("‚úÖ –°–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∞—Ü–∏—è –∑–∞–≤–µ—Ä—à–µ–Ω–∞. –ù–æ–≤—ã—Ö –ø–æ–∑–∏—Ü–∏–π –Ω–µ –æ–±–Ω–∞—Ä—É–∂–µ–Ω–æ")

            return added_count > 0

        except Exception as e:
            logger.error(f"‚ùå –û—à–∏–±–∫–∞ —Å–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∞—Ü–∏–∏ –ø–æ—Ä—Ç—Ñ–µ–ª—è: {e}")
            return False

    def get_usdt_balance(self):
        """–ü–æ–ª—É—á–µ–Ω–∏–µ –±–∞–ª–∞–Ω—Å–∞ USDT"""
        try:
            balance = self.exchange.fetch_balance()
            usdt_balance = Decimal("0")

            if "USDT" in balance:
                if isinstance(balance["USDT"], dict):
                    usdt_balance = Decimal(str(balance["USDT"].get("free", 0)))
                else:
                    usdt_balance = Decimal(str(balance["USDT"]))
            elif "total" in balance and "USDT" in balance["total"]:
                usdt_balance = Decimal(str(balance["total"]["USDT"]))

            return usdt_balance

        except Exception as e:
            logger.error(f"‚ùå –û—à–∏–±–∫–∞ –ø–æ–ª—É—á–µ–Ω–∏—è –±–∞–ª–∞–Ω—Å–∞: {e}")
            return Decimal("0")

    def get_current_portfolio(self):
        """–ü–æ–ª—É—á–µ–Ω–∏–µ —Ç–µ–∫—É—â–µ–≥–æ –ø–æ—Ä—Ç—Ñ–µ–ª—è –∏–∑ –ë–î"""
        portfolio = {}
        if self.db_conn:
            try:
                with self.db_conn.cursor() as cur:
                    cur.execute("""
                        SELECT symbol, quantity, entry_price, entry_time, current_price
                        FROM portfolio WHERE status = 'active'
                    """)
                    for row in cur.fetchall():
                        symbol, quantity, entry_price, entry_time, current_price = row
                        portfolio[symbol] = {
                            "quantity": Decimal(str(quantity)),
                            "entry_price": Decimal(str(entry_price)),
                            "entry_time": entry_time,
                            "current_price": Decimal(str(current_price))
                            if current_price
                            else Decimal("0"),
                        }
            except Exception as e:
                logger.error(f"‚ùå –û—à–∏–±–∫–∞ —á—Ç–µ–Ω–∏—è –ø–æ—Ä—Ç—Ñ–µ–ª—è: {e}")
        return portfolio

    def log_portfolio_status(self, portfolio, tickers):
        """–õ–æ–≥–∏—Ä–æ–≤–∞–Ω–∏–µ —Å—Ç–∞—Ç—É—Å–∞ –ø–æ—Ä—Ç—Ñ–µ–ª—è"""
        try:
            total_value = Decimal("0")
            total_pnl = Decimal("0")

            logger.info("üìä –°–¢–ê–¢–£–° –ü–û–†–¢–§–ï–õ–Ø:")

            for symbol, position in portfolio.items():
                if symbol in tickers:
                    current_price = tickers[symbol]["price"]
                else:
                    current_price = position.get("current_price", Decimal("0"))

                quantity = position["quantity"]
                entry_price = position["entry_price"]

                current_value = quantity * current_price
                total_value += current_value

                pnl = (current_price - entry_price) * quantity
                total_pnl += pnl
                pnl_percent = (
                    ((current_price / entry_price) - Decimal("1")) * Decimal("100")
                    if entry_price > Decimal("0")
                    else Decimal("0")
                )

                logger.info(f"   {symbol}:")
                logger.info(f"     –ö–æ–ª–∏—á–µ—Å—Ç–≤–æ: {quantity}")
                logger.info(f"     –¶–µ–Ω–∞ –≤—Ö–æ–¥–∞: {entry_price:.6f}")
                logger.info(f"     –¢–µ–∫—É—â–∞—è —Ü–µ–Ω–∞: {current_price:.6f}")
                logger.info(f"     –°—Ç–æ–∏–º–æ—Å—Ç—å: {current_value:.2f} USDT")
                logger.info(f"     PnL: {pnl:.2f} USDT ({pnl_percent:.2f}%)")

            balance = self.get_usdt_balance()
            total_assets = total_value + balance

            logger.info(f"üí∞ –ò–¢–û–ì–û:")
            logger.info(f"     –ë–∞–ª–∞–Ω—Å USDT: {balance:.2f}")
            logger.info(f"     –°—Ç–æ–∏–º–æ—Å—Ç—å –ø–æ–∑–∏—Ü–∏–π: {total_value:.2f} USDT")
            logger.info(f"     –û–±—â–∏–µ –∞–∫—Ç–∏–≤—ã: {total_assets:.2f} USDT")
            logger.info(f"     –û–±—â–∏–π PnL: {total_pnl:.2f} USDT")

        except Exception as e:
            logger.error(f"‚ùå –û—à–∏–±–∫–∞ –ª–æ–≥–∏—Ä–æ–≤–∞–Ω–∏—è —Å—Ç–∞—Ç—É—Å–∞ –ø–æ—Ä—Ç—Ñ–µ–ª—è: {e}")

    def update_portfolio_prices(self, tickers):
        """–û–±–Ω–æ–≤–ª–µ–Ω–∏–µ —Ç–µ–∫—É—â–∏—Ö —Ü–µ–Ω –≤ –ø–æ—Ä—Ç—Ñ–µ–ª–µ"""
        try:
            if not self.db_conn:
                return

            updated_count = 0
            with self.db_conn.cursor() as cur:
                for symbol in tickers:
                    if symbol in tickers:
                        current_price = tickers[symbol]["price"]
                        cur.execute(
                            """
                            UPDATE portfolio
                            SET current_price = %s
                            WHERE symbol = %s AND status = 'active'
                            """,
                            (float(current_price), symbol),
                        )
                        if cur.rowcount > 0:
                            updated_count += 1

                self.db_conn.commit()

            return updated_count > 0

        except Exception as e:
            logger.error(f"‚ùå –û—à–∏–±–∫–∞ –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è —Ü–µ–Ω –ø–æ—Ä—Ç—Ñ–µ–ª—è: {e}")
            return False

    def calculate_growth_score(self, ticker_data):
        """–†–∞—Å—á–µ—Ç —Å–∫–æ—Ä–∞ —Ä–æ—Å—Ç–∞"""
        try:
            change = ticker_data["change_24h"]
            volume = ticker_data["volume"]

            net_change = change - (self.commission * Decimal("100") * Decimal("2"))
            volume_factor = min(volume / Decimal("1000000"), Decimal("3"))
            score = net_change * volume_factor
            return score
        except Exception as e:
            return Decimal("0")

    def check_stop_conditions(self, portfolio, tickers):
        """–ü—Ä–æ–≤–µ—Ä–∫–∞ —Å—Ç–æ–ø-—É—Å–ª–æ–≤–∏–π –≤ —Ä–µ–∞–ª—å–Ω–æ–º –≤—Ä–µ–º–µ–Ω–∏"""
        positions_to_sell = []

        for symbol, position in portfolio.items():
            if symbol in tickers:
                current_price = tickers[symbol]["price"]
                entry_price = position["entry_price"]
                entry_time = position["entry_time"]

                pnl_ratio = current_price / entry_price

                # –°–¢–û–ü-–õ–û–°–°
                if pnl_ratio <= self.stop_loss:
                    positions_to_sell.append(
                        (symbol, position, current_price, "–°–¢–û–ü-–õ–û–°–°")
                    )
                    continue

                # –¢–ï–ô–ö-–ü–†–û–§–ò–¢
                if pnl_ratio >= self.take_profit:
                    positions_to_sell.append(
                        (symbol, position, current_price, "–¢–ï–ô–ö-–ü–†–û–§–ò–¢")
                    )
                    continue

                # –¢–†–ï–ô–õ–ò–ù–ì-–°–¢–û–ü
                if pnl_ratio > Decimal("1.01") and pnl_ratio <= self.trailing_stop:
                    positions_to_sell.append(
                        (symbol, position, current_price, "–¢–†–ï–ô–õ–ò–ù–ì-–°–¢–û–ü")
                    )
                    continue

                # –í–†–ï–ú–Ø –ò–°–¢–ï–ö–õ–û
                hold_time = datetime.now() - entry_time
                if hold_time > timedelta(hours=self.max_hold_hours):
                    positions_to_sell.append(
                        (symbol, position, current_price, "–í–†–ï–ú–Ø –ò–°–¢–ï–ö–õ–û")
                    )
                    continue

        return positions_to_sell

    def execute_buy_order(self, symbol, amount_usdt, price):
        """–ë—ã—Å—Ç—Ä–æ–µ –≤—ã–ø–æ–ª–Ω–µ–Ω–∏–µ –æ—Ä–¥–µ—Ä–∞ –Ω–∞ –ø–æ–∫—É–ø–∫—É"""
        try:
            available_balance = self.get_usdt_balance()
            if available_balance < amount_usdt:
                logger.debug(f"‚èπÔ∏è –ù–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ —Å—Ä–µ–¥—Å—Ç–≤ –¥–ª—è –ø–æ–∫—É–ø–∫–∏ {symbol}")
                return False

            quantity = amount_usdt / price
            quantity = Decimal(
                str(self.exchange.amount_to_precision(symbol, float(quantity)))
            )

            logger.info(
                f"üü¢ –ü–û–ö–£–ü–ö–ê: {symbol} | –°—É–º–º–∞: {amount_usdt} USDT | –¶–µ–Ω–∞: {price} | –ö–æ–ª–∏—á–µ—Å—Ç–≤–æ: {quantity}"
            )

            try:
                market = self.exchange.market(symbol)
                min_amount = market["limits"]["amount"]["min"]
                if float(quantity) < min_amount:
                    logger.debug(
                        f"‚èπÔ∏è –ö–æ–ª–∏—á–µ—Å—Ç–≤–æ {quantity} –º–µ–Ω—å—à–µ –º–∏–Ω–∏–º–∞–ª—å–Ω–æ–≥–æ {min_amount} –¥–ª—è {symbol}"
                    )
                    return False
            except:
                return False

            order = self.exchange.create_order(
                symbol=symbol,
                type="market",
                side="buy",
                amount=float(quantity),
                params={"category": "spot"},
            )

            if self.db_conn:
                with self.db_conn.cursor() as cur:
                    cur.execute(
                        """
                        INSERT INTO portfolio (symbol, quantity, entry_price, current_price)
                        VALUES (%s, %s, %s, %s)
                        """,
                        (symbol, float(quantity), float(price), float(price)),
                    )
                    self.db_conn.commit()

            logger.info(f"‚úÖ –£—Å–ø–µ—à–Ω–∞—è –ø–æ–∫—É–ø–∫–∞ {symbol}")
            return True

        except Exception as e:
            logger.error(f"‚ùå –û—à–∏–±–∫–∞ –ø–æ–∫—É–ø–∫–∏ {symbol}: {e}")
            return False

    def execute_sell_order(self, symbol, quantity, price):
        """–ë—ã—Å—Ç—Ä–æ–µ –≤—ã–ø–æ–ª–Ω–µ–Ω–∏–µ –æ—Ä–¥–µ—Ä–∞ –Ω–∞ –ø—Ä–æ–¥–∞–∂—É"""
        try:
            quantity = Decimal(
                str(self.exchange.amount_to_precision(symbol, float(quantity)))
            )

            logger.info(
                f"üî¥ –ü–†–û–î–ê–ñ–ê: {symbol} | –ö–æ–ª–∏—á–µ—Å—Ç–≤–æ: {quantity} | –¶–µ–Ω–∞: {price}"
            )

            order = self.exchange.create_order(
                symbol=symbol,
                type="market",
                side="sell",
                amount=float(quantity),
                params={"category": "spot"},
            )

            if self.db_conn:
                with self.db_conn.cursor() as cur:
                    cur.execute(
                        """
                        UPDATE portfolio SET status = 'closed'
                        WHERE symbol = %s AND status = 'active'
                        """,
                        (symbol,),
                    )
                    self.db_conn.commit()

            proceeds = Decimal(str(quantity)) * price
            logger.info(f"‚úÖ –£—Å–ø–µ—à–Ω–∞—è –ø—Ä–æ–¥–∞–∂–∞ {symbol} | –í—ã—Ä—É—á–∫–∞: {proceeds:.2f} USDT")
            return proceeds

        except Exception as e:
            logger.error(f"‚ùå –û—à–∏–±–∫–∞ –ø—Ä–æ–¥–∞–∂–∏ {symbol}: {e}")
            return Decimal("0")

    def quick_rebalance(self, iteration):
        """–ë—ã—Å—Ç—Ä–∞—è —Ä–µ–±–∞–ª–∞–Ω—Å–∏—Ä–æ–≤–∫–∞ —Å —É–ª—É—á—à–µ–Ω–Ω—ã–º –ª–æ–≥–∏—Ä–æ–≤–∞–Ω–∏–µ–º"""
        try:
            # –õ–æ–≥–∏—Ä—É–µ–º –∫–∞–∂–¥—É—é 10-—é –∏—Ç–µ—Ä–∞—Ü–∏—é –∏–ª–∏ –ø–µ—Ä–≤—É—é
            if iteration == 1 or iteration % 10 == 0:
                logger.info(f"üîÑ –ë—ã—Å—Ç—Ä–∞—è —Ä–µ–±–∞–ª–∞–Ω—Å–∏—Ä–æ–≤–∫–∞ (–∏—Ç–µ—Ä–∞—Ü–∏—è #{iteration})")

            # –ë—ã—Å—Ç—Ä–æ–µ –ø–æ–ª—É—á–µ–Ω–∏–µ –¥–∞–Ω–Ω—ã—Ö
            tickers = self.get_cached_tickers()
            available_balance = self.get_usdt_balance()
            current_portfolio = self.get_current_portfolio()

            # –õ–æ–≥–∏—Ä—É–µ–º —Å—Ç–∞—Ç—É—Å —Ä–∞–∑ –≤ –º–∏–Ω—É—Ç—É
            current_time = time.time()
            if current_time - self.last_status_log >= self.status_log_interval:
                self.log_portfolio_status(current_portfolio, tickers)
                self.last_status_log = current_time

            # –ë—ã—Å—Ç—Ä–∞—è —Å–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∞—Ü–∏—è –µ—Å–ª–∏ –Ω—É–∂–Ω–æ
            if len(current_portfolio) == 0:
                logger.info("üì• –ü–æ—Ä—Ç—Ñ–µ–ª—å –ø—É—Å—Ç, —Å–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∏—Ä—É–µ–º —Å –±–∏—Ä–∂–µ–π...")
                self.sync_portfolio_with_exchange()
                current_portfolio = self.get_current_portfolio()

            # –ë—ã—Å—Ç—Ä–æ–µ –æ–±–Ω–æ–≤–ª–µ–Ω–∏–µ —Ü–µ–Ω
            self.update_portfolio_prices(tickers)

            # –ü–†–ò–û–†–ò–¢–ï–¢ 1: –ü—Ä–æ–≤–µ—Ä–∫–∞ —Å—Ç–æ–ø-—É—Å–ª–æ–≤–∏–π
            positions_to_sell = self.check_stop_conditions(current_portfolio, tickers)

            if positions_to_sell:
                logger.info("üö® –ê–ö–¢–ò–í–ù–´–ï –°–¢–û–ü-–£–°–õ–û–í–ò–Ø:")
                for symbol, position, current_price, reason in positions_to_sell:
                    logger.info(f"   {symbol}: {reason} | –¶–µ–Ω–∞: {current_price}")
                    sold_amount = self.execute_sell_order(
                        symbol, position["quantity"], current_price
                    )
                    if sold_amount > 0:
                        logger.info(f"   üí∞ –í—ã—Ä—É—á–µ–Ω–æ: {sold_amount:.2f} USDT")
                        if symbol in current_portfolio:
                            del current_portfolio[symbol]

            # –ü–†–ò–û–†–ò–¢–ï–¢ 2: –ü–æ–∫—É–ø–∫–∞ –µ—Å–ª–∏ –µ—Å—Ç—å –º–µ—Å—Ç–æ –∏ —Å—Ä–µ–¥—Å—Ç–≤–∞
            if (
                len(current_portfolio) < self.max_positions
                and available_balance >= self.min_order + self.reserve_cash
            ):
                buy_power = available_balance - self.reserve_cash

                # –ë—ã—Å—Ç—Ä—ã–π –ø–æ–∏—Å–∫ –≤–æ–∑–º–æ–∂–Ω–æ—Å—Ç–µ–π
                opportunities = []
                for symbol, data in tickers.items():
                    if symbol not in current_portfolio:
                        score = self.calculate_growth_score(data)
                        if score > Decimal("0"):
                            opportunities.append((symbol, score, data["price"]))

                # –ë—ã—Å—Ç—Ä–∞—è —Å–æ—Ä—Ç–∏—Ä–æ–≤–∫–∞ –∏ –ø–æ–∫—É–ø–∫–∞
                opportunities.sort(key=lambda x: x[1], reverse=True)

                bought_count = 0
                for symbol, score, price in opportunities[:2]:
                    if buy_power >= self.min_order and bought_count < 2:
                        amount_to_spend = min(self.position_size, buy_power)

                        if self.execute_buy_order(symbol, amount_to_spend, price):
                            bought_count += 1
                            buy_power -= amount_to_spend
                            available_balance = self.get_usdt_balance()
                            buy_power = available_balance - self.reserve_cash

            return True

        except Exception as e:
            logger.error(f"‚ùå –û—à–∏–±–∫–∞ –±—ã—Å—Ç—Ä–æ–π —Ä–µ–±–∞–ª–∞–Ω—Å–∏—Ä–æ–≤–∫–∏: {e}")
            return False

    def run_optimized(self):
        """–û–ø—Ç–∏–º–∏–∑–∏—Ä–æ–≤–∞–Ω–Ω—ã–π –æ—Å–Ω–æ–≤–Ω–æ–π —Ü–∏–∫–ª —Å —É–ª—É—á—à–µ–Ω–Ω—ã–º –ª–æ–≥–∏—Ä–æ–≤–∞–Ω–∏–µ–º"""
        logger.info("üöÄ –ó–∞–ø—É—Å–∫ –û–ü–¢–ò–ú–ò–ó–ò–†–û–í–ê–ù–ù–û–ì–û —Å–ø–æ—Ç-–±–æ—Ç–∞ Bybit")
        logger.info(f"üíº –ö–∞–ø–∏—Ç–∞–ª: {self.total_capital} USDT")
        logger.info(f"üéØ –¶–µ–ª–∏: TP={self.take_profit} | SL={self.stop_loss}")
        logger.info(f"‚è±Ô∏è  –ò–Ω—Ç–µ—Ä–≤–∞–ª: 15 —Å–µ–∫—É–Ω–¥")
        logger.info(f"üìä –°—Ç–∞—Ç—É—Å –ø–æ—Ä—Ç—Ñ–µ–ª—è –±—É–¥–µ—Ç –æ–±–Ω–æ–≤–ª—è—Ç—å—Å—è –∫–∞–∂–¥—É—é –º–∏–Ω—É—Ç—É")

        iteration = 0
        error_count = 0
        max_errors = 5

        while True:
            try:
                iteration += 1

                if not self.db_conn or self.db_conn.closed:
                    self.db_conn = self.init_db()

                success = self.quick_rebalance(iteration)

                if success:
                    error_count = 0
                    if iteration % 40 == 0:  # –ö–∞–∂–¥—ã–µ 40 –∏—Ç–µ—Ä–∞—Ü–∏–π (~10 –º–∏–Ω—É—Ç)
                        logger.info(f"üìà –ü—Ä–æ–≥—Ä–µ—Å—Å: –∏—Ç–µ—Ä–∞—Ü–∏—è #{iteration}")
                else:
                    error_count += 1
                    if error_count >= max_errors:
                        logger.error(
                            "üö® –ü—Ä–µ–≤—ã—à–µ–Ω–æ –º–∞–∫—Å–∏–º–∞–ª—å–Ω–æ–µ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –æ—à–∏–±–æ–∫, –ø–∞—É–∑–∞ 60 —Å–µ–∫—É–Ω–¥"
                        )
                        time.sleep(60)
                        error_count = 0

                time.sleep(15)

            except KeyboardInterrupt:
                logger.info("\n‚èπÔ∏è –û—Å—Ç–∞–Ω–æ–≤–∫–∞ –±–æ—Ç–∞ –ø–æ –∑–∞–ø—Ä–æ—Å—É –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è...")
                break
            except Exception as e:
                logger.error(f"‚ùå –ö—Ä–∏—Ç–∏—á–µ—Å–∫–∞—è –æ—à–∏–±–∫–∞ –≤ –æ—Å–Ω–æ–≤–Ω–æ–º —Ü–∏–∫–ª–µ: {e}")
                error_count += 1
                time.sleep(30)


if __name__ == "__main__":
    required_env_vars = ["BYBIT_API_KEY", "BYBIT_API_SECRET"]
    missing_vars = [var for var in required_env_vars if not os.getenv(var)]

    if missing_vars:
        print(
            f"‚ùå –û—Ç—Å—É—Ç—Å—Ç–≤—É—é—Ç –æ–±—è–∑–∞—Ç–µ–ª—å–Ω—ã–µ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã–µ –æ–∫—Ä—É–∂–µ–Ω–∏—è: {', '.join(missing_vars)}"
        )
        exit(1)

    bot = BybitSpotBot()

    try:
        bot.run_optimized()
    except KeyboardInterrupt:
        logger.info("\n‚èπÔ∏è –û—Å—Ç–∞–Ω–æ–≤–∫–∞ –±–æ—Ç–∞...")
    finally:
        if bot.db_conn:
            bot.db_conn.close()
