import json
import logging
import math
import os
import time
from datetime import datetime, timedelta
from decimal import Decimal

import ccxt
import psycopg2
from dotenv import load_dotenv

# –ù–∞—Å—Ç—Ä–æ–π–∫–∞ –ª–æ–≥–∏—Ä–æ–≤–∞–Ω–∏—è
logging.basicConfig(
    level=logging.INFO,
    format="%(asctime)s - %(levelname)s - %(message)s",
    datefmt="%Y-%m-%d %H:%M:%S",
)
logger = logging.getLogger(__name__)

load_dotenv()


class BybitSpotBot:
    def __init__(self):
        self.exchange = ccxt.bybit(
            {
                "apiKey": os.getenv("BYBIT_API_KEY"),
                "secret": os.getenv("BYBIT_API_SECRET"),
                "enableRateLimit": True,
                "sandbox": False,
                "rateLimit": 100,
            }
        )

        try:
            markets = self.exchange.load_markets()
            logger.info(f"‚úÖ –£—Å–ø–µ—à–Ω–æ –ø–æ–¥–∫–ª—é—á–µ–Ω–æ –∫ Bybit. –î–æ—Å—Ç—É–ø–Ω–æ –ø–∞—Ä: {len(markets)}")

            # –î–ò–ê–ì–ù–û–°–¢–ò–ö–ê –†–´–ù–ö–û–í
            spot_usdt_pairs = [
                sym
                for sym in markets.keys()
                if markets[sym].get("spot") and "USDT" in sym
            ]
            logger.info(f"üîç –ù–∞–π–¥–µ–Ω–æ —Å–ø–æ—Ç–æ–≤—ã—Ö USDT –ø–∞—Ä: {len(spot_usdt_pairs)}")
            if spot_usdt_pairs:
                logger.info("üìä –ü—Ä–∏–º–µ—Ä—ã —Å–ø–æ—Ç–æ–≤—ã—Ö –ø–∞—Ä:")
                for symbol in spot_usdt_pairs[:5]:
                    logger.info(f"   {symbol}")

        except Exception as e:
            logger.error(f"‚ùå –û—à–∏–±–∫–∞ –ø–æ–¥–∫–ª—é—á–µ–Ω–∏—è –∫ Bybit: {e}")
            raise

        # –ö–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—è
        self.total_capital = Decimal("50")
        self.min_order = Decimal("5")
        self.commission = Decimal("0.001")
        self.max_positions = 3
        self.position_size = Decimal("12")
        self.reserve_cash = Decimal("8")

        # –ó–∞—â–∏—Ç–Ω—ã–µ –ø–∞—Ä–∞–º–µ—Ç—Ä—ã
        self.stop_loss = Decimal("0.98")
        self.take_profit = Decimal("1.03")
        self.trailing_stop = Decimal("0.985")
        self.max_hold_hours = 6

        # –ü–∞—Ä–∞–º–µ—Ç—Ä—ã –ë–î
        self.db_config = {
            "host": os.getenv("DB_HOST", "postgres"),
            "database": os.getenv("DB_NAME", "bybit_bot"),
            "user": os.getenv("DB_USER", "trader"),
            "password": os.getenv("DB_PASSWORD", "trading_password"),
            "port": os.getenv("DB_PORT", "5432"),
        }

        # –ö—ç—à–∏—Ä–æ–≤–∞–Ω–∏–µ –¥–∞–Ω–Ω—ã—Ö –¥–ª—è –æ–ø—Ç–∏–º–∏–∑–∞—Ü–∏–∏
        self.last_tickers_update = None
        self.cached_tickers = {}
        self.tickers_cache_ttl = 10
        self.last_status_log = 0
        self.status_log_interval = 60

        # –ò–ù–ò–¶–ò–ê–õ–ò–ó–ê–¶–ò–Ø –ë–î –ò –ü–û–†–¢–§–ï–õ–Ø –í –ü–†–ê–í–ò–õ–¨–ù–û–ú –ü–û–†–Ø–î–ö–ï
        self.db_conn = self.init_db()

        # –¢–µ–ø–µ—Ä—å, –∫–æ–≥–¥–∞ db_conn —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω, –º–æ–∂–Ω–æ –ª–æ–≥–∏—Ä–æ–≤–∞—Ç—å –ø–æ—Ä—Ç—Ñ–µ–ª—å
        if self.db_conn:
            self.log_initial_portfolio()
        else:
            logger.warning(
                "‚ö†Ô∏è –ë–∞–∑–∞ –¥–∞–Ω–Ω—ã—Ö –Ω–µ –¥–æ—Å—Ç—É–ø–Ω–∞, —Ä–∞–±–æ—Ç–∞–µ–º –±–µ–∑ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è —Å–æ—Å—Ç–æ—è–Ω–∏—è"
            )

    def init_db(self):
        """–ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è PostgreSQL —Å–æ–µ–¥–∏–Ω–µ–Ω–∏—è - –¢–û–õ–¨–ö–û —Å–æ–∑–¥–∞–Ω–∏–µ —Å–æ–µ–¥–∏–Ω–µ–Ω–∏—è"""
        try:
            conn = psycopg2.connect(**self.db_config)
            with conn.cursor() as cur:
                cur.execute("""
                    CREATE TABLE IF NOT EXISTS portfolio (
                        id SERIAL PRIMARY KEY,
                        symbol VARCHAR(50) NOT NULL,
                        quantity DECIMAL(20,8) NOT NULL,
                        entry_price DECIMAL(20,8) NOT NULL,
                        current_price DECIMAL(20,8),
                        entry_time TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                        profit_loss DECIMAL(10,4),
                        status VARCHAR(10) DEFAULT 'active'
                    )
                """)
                cur.execute("""
                    CREATE TABLE IF NOT EXISTS transactions (
                        id SERIAL PRIMARY KEY,
                        symbol VARCHAR(50) NOT NULL,
                        side VARCHAR(10) NOT NULL,
                        quantity DECIMAL(20,8) NOT NULL,
                        price DECIMAL(20,8) NOT NULL,
                        fee DECIMAL(20,8),
                        total DECIMAL(20,8) NOT NULL,
                        timestamp TIMESTAMP DEFAULT CURRENT_TIMESTAMP
                    )
                """)
            conn.commit()
            logger.info("‚úÖ –ë–∞–∑–∞ –¥–∞–Ω–Ω—ã—Ö –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω–∞")
            return conn

        except Exception as e:
            logger.error(f"‚ùå –û—à–∏–±–∫–∞ –ø–æ–¥–∫–ª—é—á–µ–Ω–∏—è –∫ –ë–î: {e}")
            return None

    def log_initial_portfolio(self):
        """–õ–æ–≥–∏—Ä–æ–≤–∞–Ω–∏–µ –Ω–∞—á–∞–ª—å–Ω–æ–≥–æ —Å–æ—Å—Ç–æ—è–Ω–∏—è –ø–æ—Ä—Ç—Ñ–µ–ª—è"""
        try:
            portfolio = self.get_current_portfolio()
            balance = self.get_usdt_balance()

            logger.info("üìä –ù–ê–ß–ê–õ–¨–ù–û–ï –°–û–°–¢–û–Ø–ù–ò–ï –ü–û–†–¢–§–ï–õ–Ø:")
            logger.info(f"üí∞ –ë–∞–ª–∞–Ω—Å USDT: {balance}")
            logger.info(f"üì¶ –ü–æ–∑–∏—Ü–∏–π –≤ –ø–æ—Ä—Ç—Ñ–µ–ª–µ: {len(portfolio)}")

            if portfolio:
                logger.info("üîç –î–µ—Ç–∞–ª–∏ –ø–æ—Ä—Ç—Ñ–µ–ª—è:")
                total_value = Decimal("0")
                for symbol, position in portfolio.items():
                    current_price = position.get("current_price", Decimal("0"))
                    quantity = position["quantity"]
                    value = quantity * current_price
                    total_value += value
                    logger.info(
                        f"   {symbol}: {quantity} √ó {current_price} = {value:.2f} USDT"
                    )

                logger.info(f"üìà –û–±—â–∞—è —Å—Ç–æ–∏–º–æ—Å—Ç—å –ø–æ—Ä—Ç—Ñ–µ–ª—è: {total_value:.2f} USDT")
            else:
                logger.info("üí° –ü–æ—Ä—Ç—Ñ–µ–ª—å –ø—É—Å—Ç")

        except Exception as e:
            logger.error(f"‚ùå –û—à–∏–±–∫–∞ –ª–æ–≥–∏—Ä–æ–≤–∞–Ω–∏—è –Ω–∞—á–∞–ª—å–Ω–æ–≥–æ –ø–æ—Ä—Ç—Ñ–µ–ª—è: {e}")

    def get_cached_tickers(self):
        """–ü–æ–ª—É—á–µ–Ω–∏–µ —Ç–∏–∫–µ—Ä–æ–≤ —Å –∫—ç—à–∏—Ä–æ–≤–∞–Ω–∏–µ–º –∏ –ª–æ–≥–∏—Ä–æ–≤–∞–Ω–∏–µ–º –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è"""
        current_time = time.time()

        if (
            self.last_tickers_update is None
            or current_time - self.last_tickers_update > self.tickers_cache_ttl
            or not self.cached_tickers
        ):
            try:
                old_count = len(self.cached_tickers)
                self.cached_tickers = self.enhanced_fetch_filtered_tickers()
                self.last_tickers_update = current_time

                new_count = len(self.cached_tickers)
                logger.debug(f"üîÑ –û–±–Ω–æ–≤–ª–µ–Ω –∫—ç—à —Ç–∏–∫–µ—Ä–æ–≤: {old_count} -> {new_count} –ø–∞—Ä")

            except Exception as e:
                logger.error(f"‚ùå –û—à–∏–±–∫–∞ –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è –∫—ç—à–∞ —Ç–∏–∫–µ—Ä–æ–≤: {e}")

        return self.cached_tickers

    def enhanced_fetch_filtered_tickers(self):
        """–†–ê–°–®–ò–†–ï–ù–ù–´–ô –º–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥ –í–°–ï–• –ø–∞—Ä —Å —É–ª—É—á—à–µ–Ω–Ω–æ–π —Ñ–∏–ª—å—Ç—Ä–∞—Ü–∏–µ–π"""
        try:
            tickers = self.exchange.fetch_tickers()
            logger.info(f"üìà –ó–∞–≥—Ä—É–∂–µ–Ω–æ —Ç–∏–∫–µ—Ä–æ–≤: {len(tickers)}")

            filtered = {}
            categories = {
                "low_cap": [],  # < 1 USDT
                "mid_cap": [],  # 1-50 USDT
                "high_cap": [],  # > 50 USDT
                "meme": [],  # –í—ã—Å–æ–∫–∞—è –≤–æ–ª–∞—Ç–∏–ª—å–Ω–æ—Å—Ç—å
                "defi": [],  # DeFi —Ç–æ–∫–µ–Ω—ã
                "ai": [],  # AI —Ç–æ–∫–µ–Ω—ã
            }

            for symbol, ticker in tickers.items():
                if "/USDT:USDT" in symbol:
                    try:
                        price = (
                            Decimal(str(ticker.get("last", 0)))
                            if ticker.get("last")
                            else Decimal("0")
                        )
                        volume = (
                            Decimal(str(ticker.get("baseVolume", 0)))
                            if ticker.get("baseVolume")
                            else Decimal("0")
                        )
                        change_24h = (
                            Decimal(str(ticker.get("percentage", 0)))
                            if ticker.get("percentage")
                            else Decimal("0")
                        )

                        # –†–ê–°–®–ò–†–ï–ù–ù–´–ï –§–ò–õ–¨–¢–†–´
                        price_ok = price > Decimal("0.0001") and price <= Decimal(
                            "100"
                        )  # –£–≤–µ–ª–∏—á–∏–ª –¥–æ 100 USDT
                        volume_ok = volume >= Decimal("10000")  # –ë–æ–ª—å—à–µ –ª–∏–∫–≤–∏–¥–Ω–æ—Å—Ç–∏
                        change_ok = change_24h > Decimal(
                            "-80"
                        ) and change_24h < Decimal("1000")  # –®–∏—Ä–µ –¥–∏–∞–ø–∞–∑–æ–Ω

                        # –ö–ê–¢–ï–ì–û–†–ò–ó–ê–¶–ò–Ø
                        base_symbol = symbol.replace("/USDT:USDT", "USDT")

                        if price_ok and volume_ok and change_ok:
                            # –£–õ–£–ß–®–ï–ù–ù–´–ô –°–ö–û–†–ò–ù–ì
                            enhanced_score = self.calculate_enhanced_growth_score(
                                {
                                    "price": price,
                                    "volume": volume,
                                    "change_24h": change_24h,
                                    "symbol": base_symbol,
                                }
                            )

                            filtered[base_symbol] = {
                                "price": price,
                                "volume": volume,
                                "change_24h": change_24h,
                                "symbol": base_symbol,
                                "original_symbol": symbol,
                                "score": enhanced_score,
                                "category": self.categorize_asset(
                                    base_symbol, price, volume, change_24h
                                ),
                            }

                            # –†–∞—Å–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ –ø–æ –∫–∞—Ç–µ–≥–æ—Ä–∏—è–º
                            if price < Decimal("1"):
                                categories["low_cap"].append(base_symbol)
                            elif price < Decimal("50"):
                                categories["mid_cap"].append(base_symbol)
                            else:
                                categories["high_cap"].append(base_symbol)

                            # –î–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω—ã–µ –∫–∞—Ç–µ–≥–æ—Ä–∏–∏ –ø–æ –Ω–∞–∑–≤–∞–Ω–∏—é
                            if any(
                                keyword in base_symbol.upper()
                                for keyword in ["FLOKI", "SHIB", "BONK", "PEPE", "DOGE"]
                            ):
                                categories["meme"].append(base_symbol)
                            if any(
                                keyword in base_symbol.upper()
                                for keyword in ["UNI", "AAVE", "COMP", "MKR", "CRV"]
                            ):
                                categories["defi"].append(base_symbol)
                            if any(
                                keyword in base_symbol.upper()
                                for keyword in ["AI", "AGIX", "FET", "OCEAN", "NMR"]
                            ):
                                categories["ai"].append(base_symbol)

                    except Exception as e:
                        continue

            # –õ–û–ì–ò–†–û–í–ê–ù–ò–ï –°–¢–ê–¢–ò–°–¢–ò–ö–ò
            logger.info("üéØ –°–¢–ê–¢–ò–°–¢–ò–ö–ê –†–´–ù–ö–ê:")
            logger.info(
                f"   –ù–∏–∑–∫–∞—è –∫–∞–ø–∏—Ç–∞–ª–∏–∑–∞—Ü–∏—è (<1$): {len(categories['low_cap'])} –ø–∞—Ä"
            )
            logger.info(
                f"   –°—Ä–µ–¥–Ω—è—è –∫–∞–ø–∏—Ç–∞–ª–∏–∑–∞—Ü–∏—è (1-50$): {len(categories['mid_cap'])} –ø–∞—Ä"
            )
            logger.info(
                f"   –í—ã—Å–æ–∫–∞—è –∫–∞–ø–∏—Ç–∞–ª–∏–∑–∞—Ü–∏—è (>50$): {len(categories['high_cap'])} –ø–∞—Ä"
            )
            logger.info(f"   Meme —Ç–æ–∫–µ–Ω—ã: {len(categories['meme'])} –ø–∞—Ä")
            logger.info(f"   DeFi —Ç–æ–∫–µ–Ω—ã: {len(categories['defi'])} –ø–∞—Ä")
            logger.info(f"   AI —Ç–æ–∫–µ–Ω—ã: {len(categories['ai'])} –ø–∞—Ä")
            logger.info(f"   –í–°–ï–ì–û –æ—Ç—Ñ–∏–ª—å—Ç—Ä–æ–≤–∞–Ω–æ: {len(filtered)} –ø–∞—Ä")

            return filtered

        except Exception as e:
            logger.error(f"‚ùå –û—à–∏–±–∫–∞ —Ä–∞—Å—à–∏—Ä–µ–Ω–Ω–æ–≥–æ –º–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥–∞: {e}")
            return {}

    def calculate_enhanced_growth_score(self, ticker_data):
        """–£–ª—É—á—à–µ–Ω–Ω—ã–π —Ä–∞—Å—á–µ—Ç —Å–∫–æ—Ä–∞ —Å —É—á–µ—Ç–æ–º multiple —Ñ–∞–∫—Ç–æ—Ä–æ–≤"""
        try:
            change = ticker_data["change_24h"]
            volume = ticker_data["volume"]
            price = ticker_data["price"]

            # 1. –ë–∞–∑–æ–≤—ã–π —Å–∫–æ—Ä –Ω–∞ –æ—Å–Ω–æ–≤–µ –∏–∑–º–µ–Ω–µ–Ω–∏—è —Ü–µ–Ω—ã
            price_score = change * Decimal("2")

            # 2. –û–±—ä–µ–º–Ω—ã–π —Ñ–∞–∫—Ç–æ—Ä (–ª–æ–≥–∞—Ä–∏—Ñ–º–∏—á–µ—Å–∫–∏–π)
            volume_factor = Decimal(math.log(max(float(volume), 10000) / 10000))
            volume_score = volume_factor * Decimal("5")

            # 3. –§–∞–∫—Ç–æ—Ä —Ü–µ–Ω—ã (–ø—Ä–µ—Ñ–µ—Ä–µ–Ω—Ü–∏—è –Ω–∏–∑–∫–æ–π —Ü–µ–Ω–µ)
            price_factor = max(Decimal("0.5"), Decimal("2") - (price / Decimal("10")))

            # 4. –í–æ–ª–∞—Ç–∏–ª—å–Ω–æ—Å—Ç—å penalty
            volatility_penalty = Decimal("0")
            if abs(change) > Decimal("50"):
                volatility_penalty = (abs(change) - Decimal("50")) * Decimal("0.1")

            # 5. –ö–æ–º–∏—Å—Å–∏–æ–Ω–Ω—ã–µ –∏–∑–¥–µ—Ä–∂–∫–∏
            commission_cost = self.commission * Decimal("200")

            final_score = (
                (price_score + volume_score) * price_factor
                - volatility_penalty
                - commission_cost
            )
            return final_score

        except Exception as e:
            logger.error(f"‚ùå –û—à–∏–±–∫–∞ —Ä–∞—Å—á–µ—Ç–∞ —É–ª—É—á—à–µ–Ω–Ω–æ–≥–æ —Å–∫–æ—Ä–∞: {e}")
            return Decimal("0")

    def categorize_asset(self, symbol, price, volume, change_24h):
        """–ö–∞—Ç–µ–≥–æ—Ä–∏–∑–∞—Ü–∏—è –∞–∫—Ç–∏–≤–∞ –¥–ª—è –¥–∏–≤–µ—Ä—Å–∏—Ñ–∏–∫–∞—Ü–∏–∏"""
        # –ü–æ —Ü–µ–Ω–µ
        if price < Decimal("0.01"):
            return "micro_cap"
        elif price < Decimal("1"):
            return "low_cap"
        elif price < Decimal("10"):
            return "mid_cap"
        else:
            return "high_cap"

    def get_usdt_balance(self):
        """–ü–æ–ª—É—á–µ–Ω–∏–µ –±–∞–ª–∞–Ω—Å–∞ USDT"""
        try:
            balance = self.exchange.fetch_balance()
            usdt_balance = Decimal("0")

            if "USDT" in balance:
                if isinstance(balance["USDT"], dict):
                    usdt_balance = Decimal(str(balance["USDT"].get("free", 0)))
                else:
                    usdt_balance = Decimal(str(balance["USDT"]))
            elif "total" in balance and "USDT" in balance["total"]:
                usdt_balance = Decimal(str(balance["total"]["USDT"]))

            return usdt_balance

        except Exception as e:
            logger.error(f"‚ùå –û—à–∏–±–∫–∞ –ø–æ–ª—É—á–µ–Ω–∏—è –±–∞–ª–∞–Ω—Å–∞: {e}")
            return Decimal("0")

    def get_current_portfolio(self):
        """–ü–æ–ª—É—á–µ–Ω–∏–µ —Ç–µ–∫—É—â–µ–≥–æ –ø–æ—Ä—Ç—Ñ–µ–ª—è –∏–∑ –ë–î"""
        portfolio = {}
        if self.db_conn:
            try:
                with self.db_conn.cursor() as cur:
                    cur.execute("""
                        SELECT symbol, quantity, entry_price, entry_time, current_price
                        FROM portfolio WHERE status = 'active'
                    """)
                    for row in cur.fetchall():
                        symbol, quantity, entry_price, entry_time, current_price = row
                        portfolio[symbol] = {
                            "quantity": Decimal(str(quantity)),
                            "entry_price": Decimal(str(entry_price)),
                            "entry_time": entry_time,
                            "current_price": Decimal(str(current_price))
                            if current_price
                            else Decimal("0"),
                        }
            except Exception as e:
                logger.error(f"‚ùå –û—à–∏–±–∫–∞ —á—Ç–µ–Ω–∏—è –ø–æ—Ä—Ç—Ñ–µ–ª—è: {e}")
        return portfolio

    def sync_portfolio_with_exchange(self):
        """–°–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∞—Ü–∏—è –ø–æ—Ä—Ç—Ñ–µ–ª—è —Å –±–∏—Ä–∂–µ–π —Å –ª–æ–≥–∏—Ä–æ–≤–∞–Ω–∏–µ–º"""
        try:
            balance = self.exchange.fetch_balance()
            db_portfolio = self.get_current_portfolio()
            added_count = 0

            logger.debug("üîÑ –°–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∞—Ü–∏—è –ø–æ—Ä—Ç—Ñ–µ–ª—è —Å –±–∏—Ä–∂–µ–π...")

            for currency, data in balance.items():
                if currency in [
                    "free",
                    "used",
                    "total",
                    "info",
                    "timestamp",
                    "datetime",
                ]:
                    continue

                if isinstance(data, dict):
                    free_balance = Decimal(str(data.get("free", 0)))
                    if free_balance > Decimal("0.0001") and currency != "USDT":
                        symbol = f"{currency}USDT"

                        if symbol not in db_portfolio:
                            logger.info(
                                f"üì• –û–±–Ω–∞—Ä—É–∂–µ–Ω–∞ –Ω–æ–≤–∞—è –ø–æ–∑–∏—Ü–∏—è –Ω–∞ –±–∏—Ä–∂–µ: {symbol}"
                            )

                            try:
                                ticker = self.exchange.fetch_ticker(symbol)
                                current_price = (
                                    Decimal(str(ticker["last"]))
                                    if ticker.get("last")
                                    else Decimal("0")
                                )

                                if current_price > Decimal("0") and self.db_conn:
                                    with self.db_conn.cursor() as cur:
                                        cur.execute(
                                            """
                                            INSERT INTO portfolio (symbol, quantity, entry_price, current_price)
                                            VALUES (%s, %s, %s, %s)
                                            """,
                                            (
                                                symbol,
                                                float(free_balance),
                                                float(current_price),
                                                float(current_price),
                                            ),
                                        )
                                    self.db_conn.commit()
                                    logger.info(
                                        f"‚úÖ –î–æ–±–∞–≤–ª–µ–Ω–∞ –ø–æ–∑–∏—Ü–∏—è {symbol}: {free_balance} –ø–æ —Ü–µ–Ω–µ {current_price}"
                                    )
                                    added_count += 1

                            except Exception as e:
                                logger.error(f"‚ùå –û—à–∏–±–∫–∞ –¥–æ–±–∞–≤–ª–µ–Ω–∏—è {symbol}: {e}")

            if added_count > 0:
                logger.info(
                    f"‚úÖ –°–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∞—Ü–∏—è –∑–∞–≤–µ—Ä—à–µ–Ω–∞. –î–æ–±–∞–≤–ª–µ–Ω–æ –ø–æ–∑–∏—Ü–∏–π: {added_count}"
                )
            else:
                logger.debug("‚úÖ –°–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∞—Ü–∏—è –∑–∞–≤–µ—Ä—à–µ–Ω–∞. –ù–æ–≤—ã—Ö –ø–æ–∑–∏—Ü–∏–π –Ω–µ –æ–±–Ω–∞—Ä—É–∂–µ–Ω–æ")

            return added_count > 0

        except Exception as e:
            logger.error(f"‚ùå –û—à–∏–±–∫–∞ —Å–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∞—Ü–∏–∏ –ø–æ—Ä—Ç—Ñ–µ–ª—è: {e}")
            return False

    def update_portfolio_prices(self, tickers):
        """–û–±–Ω–æ–≤–ª–µ–Ω–∏–µ —Ç–µ–∫—É—â–∏—Ö —Ü–µ–Ω –≤ –ø–æ—Ä—Ç—Ñ–µ–ª–µ"""
        try:
            if not self.db_conn:
                return

            updated_count = 0
            with self.db_conn.cursor() as cur:
                for symbol in tickers:
                    if symbol in tickers:
                        current_price = tickers[symbol]["price"]
                        cur.execute(
                            """
                            UPDATE portfolio
                            SET current_price = %s
                            WHERE symbol = %s AND status = 'active'
                            """,
                            (float(current_price), symbol),
                        )
                        if cur.rowcount > 0:
                            updated_count += 1

                self.db_conn.commit()

            return updated_count > 0

        except Exception as e:
            logger.error(f"‚ùå –û—à–∏–±–∫–∞ –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è —Ü–µ–Ω –ø–æ—Ä—Ç—Ñ–µ–ª—è: {e}")
            return False

    def analyze_portfolio_diversification(self, portfolio, tickers):
        """–ê–Ω–∞–ª–∏–∑ –¥–∏–≤–µ—Ä—Å–∏—Ñ–∏–∫–∞—Ü–∏–∏ —Ç–µ–∫—É—â–µ–≥–æ –ø–æ—Ä—Ç—Ñ–µ–ª—è"""
        categories_count = {
            "micro_cap": 0,
            "low_cap": 0,
            "mid_cap": 0,
            "high_cap": 0,
            "meme": 0,
            "defi": 0,
            "ai": 0,
        }

        for symbol in portfolio:
            if symbol in tickers:
                category = tickers[symbol].get("category", "unknown")
                categories_count[category] = categories_count.get(category, 0) + 1

        logger.info("üéØ –î–ò–í–ï–†–°–ò–§–ò–ö–ê–¶–ò–Ø –ü–û–†–¢–§–ï–õ–Ø:")
        for category, count in categories_count.items():
            if count > 0:
                logger.info(f"   {category}: {count} –ø–æ–∑–∏—Ü–∏–π")

        return categories_count

    def find_diversified_opportunities(self, tickers, portfolio, current_categories):
        """–ü–æ–∏—Å–∫ –≤–æ–∑–º–æ–∂–Ω–æ—Å—Ç–µ–π —Å —É—á–µ—Ç–æ–º –¥–∏–≤–µ—Ä—Å–∏—Ñ–∏–∫–∞—Ü–∏–∏"""
        opportunities = []

        for symbol, data in tickers.items():
            if symbol not in portfolio:
                category = data.get("category", "unknown")
                score = data["score"]
                price = data["price"]

                # –ë–û–ù–£–° –∑–∞ –Ω–µ–¥–æ—Å—Ç–∞—é—â–∏–µ –∫–∞—Ç–µ–≥–æ—Ä–∏–∏
                diversification_bonus = Decimal("0")
                if current_categories.get(category, 0) == 0:
                    diversification_bonus = Decimal("10")  # –ë–æ–Ω—É—Å –∑–∞ –Ω–æ–≤—É—é –∫–∞—Ç–µ–≥–æ—Ä–∏—é
                elif current_categories.get(category, 0) <= 1:
                    diversification_bonus = Decimal("5")  # –ú–∞–ª—ã–π –±–æ–Ω—É—Å

                final_score = score + diversification_bonus
                opportunities.append((symbol, final_score, price, category))

        # –°–æ—Ä—Ç–∏—Ä–æ–≤–∫–∞ –ø–æ –∏—Ç–æ–≥–æ–≤–æ–º—É —Å–∫–æ—Ä—É
        opportunities.sort(key=lambda x: x[1], reverse=True)
        return opportunities[:5]  # –í–æ–∑–≤—Ä–∞—â–∞–µ–º —Ç–æ–ø-5

    def check_stop_conditions(self, portfolio, tickers):
        """–ü—Ä–æ–≤–µ—Ä–∫–∞ —Å—Ç–æ–ø-—É—Å–ª–æ–≤–∏–π –≤ —Ä–µ–∞–ª—å–Ω–æ–º –≤—Ä–µ–º–µ–Ω–∏"""
        positions_to_sell = []

        for symbol, position in portfolio.items():
            if symbol in tickers:
                current_price = tickers[symbol]["price"]
                entry_price = position["entry_price"]
                entry_time = position["entry_time"]

                pnl_ratio = current_price / entry_price

                # –°–¢–û–ü-–õ–û–°–°
                if pnl_ratio <= self.stop_loss:
                    positions_to_sell.append(
                        (symbol, position, current_price, "–°–¢–û–ü-–õ–û–°–°")
                    )
                    continue

                # –¢–ï–ô–ö-–ü–†–û–§–ò–¢
                if pnl_ratio >= self.take_profit:
                    positions_to_sell.append(
                        (symbol, position, current_price, "–¢–ï–ô–ö-–ü–†–û–§–ò–¢")
                    )
                    continue

                # –¢–†–ï–ô–õ–ò–ù–ì-–°–¢–û–ü
                if pnl_ratio > Decimal("1.01") and pnl_ratio <= self.trailing_stop:
                    positions_to_sell.append(
                        (symbol, position, current_price, "–¢–†–ï–ô–õ–ò–ù–ì-–°–¢–û–ü")
                    )
                    continue

                # –í–†–ï–ú–Ø –ò–°–¢–ï–ö–õ–û
                hold_time = datetime.now() - entry_time
                if hold_time > timedelta(hours=self.max_hold_hours):
                    positions_to_sell.append(
                        (symbol, position, current_price, "–í–†–ï–ú–Ø –ò–°–¢–ï–ö–õ–û")
                    )
                    continue

        return positions_to_sell

    def execute_buy_order(self, symbol, amount_usdt, price):
        """–ë—ã—Å—Ç—Ä–æ–µ –≤—ã–ø–æ–ª–Ω–µ–Ω–∏–µ –æ—Ä–¥–µ—Ä–∞ –Ω–∞ –ø–æ–∫—É–ø–∫—É"""
        try:
            available_balance = self.get_usdt_balance()
            if available_balance < amount_usdt:
                logger.debug(f"‚èπÔ∏è –ù–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ —Å—Ä–µ–¥—Å—Ç–≤ –¥–ª—è –ø–æ–∫—É–ø–∫–∏ {symbol}")
                return False

            quantity = amount_usdt / price
            quantity = Decimal(
                str(self.exchange.amount_to_precision(symbol, float(quantity)))
            )

            logger.info(
                f"üü¢ –ü–û–ö–£–ü–ö–ê: {symbol} | –°—É–º–º–∞: {amount_usdt} USDT | –¶–µ–Ω–∞: {price} | –ö–æ–ª–∏—á–µ—Å—Ç–≤–æ: {quantity}"
            )

            try:
                market = self.exchange.market(symbol)
                min_amount = market["limits"]["amount"]["min"]
                if float(quantity) < min_amount:
                    logger.debug(
                        f"‚èπÔ∏è –ö–æ–ª–∏—á–µ—Å—Ç–≤–æ {quantity} –º–µ–Ω—å—à–µ –º–∏–Ω–∏–º–∞–ª—å–Ω–æ–≥–æ {min_amount} –¥–ª—è {symbol}"
                    )
                    return False
            except:
                return False

            order = self.exchange.create_order(
                symbol=symbol,
                type="market",
                side="buy",
                amount=float(quantity),
                params={"category": "spot"},
            )

            if self.db_conn:
                with self.db_conn.cursor() as cur:
                    cur.execute(
                        """
                        INSERT INTO portfolio (symbol, quantity, entry_price, current_price)
                        VALUES (%s, %s, %s, %s)
                        """,
                        (symbol, float(quantity), float(price), float(price)),
                    )
                    self.db_conn.commit()

            logger.info(f"‚úÖ –£—Å–ø–µ—à–Ω–∞—è –ø–æ–∫—É–ø–∫–∞ {symbol}")
            return True

        except Exception as e:
            logger.error(f"‚ùå –û—à–∏–±–∫–∞ –ø–æ–∫—É–ø–∫–∏ {symbol}: {e}")
            return False

    def execute_sell_order(self, symbol, quantity, price):
        """–ë—ã—Å—Ç—Ä–æ–µ –≤—ã–ø–æ–ª–Ω–µ–Ω–∏–µ –æ—Ä–¥–µ—Ä–∞ –Ω–∞ –ø—Ä–æ–¥–∞–∂—É"""
        try:
            quantity = Decimal(
                str(self.exchange.amount_to_precision(symbol, float(quantity)))
            )

            logger.info(
                f"üî¥ –ü–†–û–î–ê–ñ–ê: {symbol} | –ö–æ–ª–∏—á–µ—Å—Ç–≤–æ: {quantity} | –¶–µ–Ω–∞: {price}"
            )

            order = self.exchange.create_order(
                symbol=symbol,
                type="market",
                side="sell",
                amount=float(quantity),
                params={"category": "spot"},
            )

            if self.db_conn:
                with self.db_conn.cursor() as cur:
                    cur.execute(
                        """
                        UPDATE portfolio SET status = 'closed'
                        WHERE symbol = %s AND status = 'active'
                        """,
                        (symbol,),
                    )
                    self.db_conn.commit()

            proceeds = Decimal(str(quantity)) * price
            logger.info(f"‚úÖ –£—Å–ø–µ—à–Ω–∞—è –ø—Ä–æ–¥–∞–∂–∞ {symbol} | –í—ã—Ä—É—á–∫–∞: {proceeds:.2f} USDT")
            return proceeds

        except Exception as e:
            logger.error(f"‚ùå –û—à–∏–±–∫–∞ –ø—Ä–æ–¥–∞–∂–∏ {symbol}: {e}")
            return Decimal("0")

    def log_enhanced_portfolio_status(self, portfolio, tickers):
        """–£–ª—É—á—à–µ–Ω–Ω–æ–µ –ª–æ–≥–∏—Ä–æ–≤–∞–Ω–∏–µ —Å—Ç–∞—Ç—É—Å–∞ –ø–æ—Ä—Ç—Ñ–µ–ª—è"""
        try:
            total_value = Decimal("0")
            total_pnl = Decimal("0")
            category_value = {}

            logger.info("üìä –†–ê–°–®–ò–†–ï–ù–ù–´–ô –°–¢–ê–¢–£–° –ü–û–†–¢–§–ï–õ–Ø:")

            for symbol, position in portfolio.items():
                if symbol in tickers:
                    current_price = tickers[symbol]["price"]
                    category = tickers[symbol].get("category", "unknown")
                else:
                    current_price = position.get("current_price", Decimal("0"))
                    category = "unknown"

                quantity = position["quantity"]
                entry_price = position["entry_price"]

                current_value = quantity * current_price
                total_value += current_value

                # –ù–∞–∫–æ–ø–ª–µ–Ω–∏–µ –ø–æ –∫–∞—Ç–µ–≥–æ—Ä–∏—è–º
                category_value[category] = (
                    category_value.get(category, Decimal("0")) + current_value
                )

                pnl = (current_price - entry_price) * quantity
                total_pnl += pnl
                pnl_percent = (
                    ((current_price / entry_price) - Decimal("1")) * Decimal("100")
                    if entry_price > Decimal("0")
                    else Decimal("0")
                )

                logger.info(f"   {symbol} [{category}]:")
                logger.info(f"     PnL: {pnl:.2f} USDT ({pnl_percent:.2f}%)")
                logger.info(f"     –°—Ç–æ–∏–º–æ—Å—Ç—å: {current_value:.2f} USDT")

            balance = self.get_usdt_balance()
            total_assets = total_value + balance

            logger.info(f"üí∞ –†–ê–°–ü–†–ï–î–ï–õ–ï–ù–ò–ï –ü–û –ö–ê–¢–ï–ì–û–†–ò–Ø–ú:")
            for category, value in category_value.items():
                percent = (
                    (value / total_value * Decimal("100"))
                    if total_value > Decimal("0")
                    else Decimal("0")
                )
                logger.info(f"   {category}: {value:.2f} USDT ({percent:.1f}%)")

            logger.info(f"üìà –ò–¢–û–ì–û:")
            logger.info(f"     –û–±—â–∏–µ –∞–∫—Ç–∏–≤—ã: {total_assets:.2f} USDT")
            logger.info(f"     –û–±—â–∏–π PnL: {total_pnl:.2f} USDT")

        except Exception as e:
            logger.error(f"‚ùå –û—à–∏–±–∫–∞ —Ä–∞—Å—à–∏—Ä–µ–Ω–Ω–æ–≥–æ –ª–æ–≥–∏—Ä–æ–≤–∞–Ω–∏—è: {e}")

    def enhanced_rebalance(self, iteration):
        """–£–õ–£–ß–®–ï–ù–ù–ê–Ø —Ä–µ–±–∞–ª–∞–Ω—Å–∏—Ä–æ–≤–∫–∞ —Å –¥–∏–≤–µ—Ä—Å–∏—Ñ–∏–∫–∞—Ü–∏–µ–π"""
        try:
            if iteration == 1 or iteration % 10 == 0:
                logger.info(f"üîÑ –£–õ–£–ß–®–ï–ù–ù–ê–Ø —Ä–µ–±–∞–ª–∞–Ω—Å–∏—Ä–æ–≤–∫–∞ (–∏—Ç–µ—Ä–∞—Ü–∏—è #{iteration})")

            # –†–ê–°–®–ò–†–ï–ù–ù–´–ô –ú–û–ù–ò–¢–û–†–ò–ù–ì
            tickers = self.get_cached_tickers()
            available_balance = self.get_usdt_balance()
            current_portfolio = self.get_current_portfolio()

            # –ê–ù–ê–õ–ò–ó –¢–û–ü-–í–û–ó–ú–û–ñ–ù–û–°–¢–ï–ô
            if tickers:
                top_opportunities = sorted(
                    tickers.items(), key=lambda x: x[1]["score"], reverse=True
                )[:10]
                logger.info("üèÜ –¢–û–ü-10 –≤–æ–∑–º–æ–∂–Ω–æ—Å—Ç–µ–π:")
                for i, (symbol, data) in enumerate(top_opportunities[:5], 1):
                    logger.info(
                        f"   {i}. {symbol}: —Å–∫–æ—Ä={data['score']:.2f}, —Ü–µ–Ω–∞={data['price']}, –∫–∞—Ç={data['category']}"
                    )

            current_time = time.time()
            if current_time - self.last_status_log >= self.status_log_interval:
                self.log_enhanced_portfolio_status(current_portfolio, tickers)
                self.last_status_log = current_time

            # –°–ò–ù–•–†–û–ù–ò–ó–ê–¶–ò–Ø
            if len(current_portfolio) == 0:
                logger.info("üì• –ü–æ—Ä—Ç—Ñ–µ–ª—å –ø—É—Å—Ç, —Å–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∏—Ä—É–µ–º —Å –±–∏—Ä–∂–µ–π...")
                self.sync_portfolio_with_exchange()
                current_portfolio = self.get_current_portfolio()

            # –û–ë–ù–û–í–õ–ï–ù–ò–ï –¶–ï–ù
            self.update_portfolio_prices(tickers)

            # –ü–†–ò–û–†–ò–¢–ï–¢ 1: –ü–†–û–î–ê–ñ–ê
            positions_to_sell = self.check_stop_conditions(current_portfolio, tickers)

            if positions_to_sell:
                logger.info("üö® –ê–ö–¢–ò–í–ù–´–ï –°–¢–û–ü-–£–°–õ–û–í–ò–Ø:")
                for symbol, position, current_price, reason in positions_to_sell:
                    logger.info(f"   {symbol}: {reason} | –¶–µ–Ω–∞: {current_price}")
                    sold_amount = self.execute_sell_order(
                        symbol, position["quantity"], current_price
                    )
                    if sold_amount > 0:
                        logger.info(f"   üí∞ –í—ã—Ä—É—á–µ–Ω–æ: {sold_amount:.2f} USDT")
                        if symbol in current_portfolio:
                            del current_portfolio[symbol]

            # –ü–†–ò–û–†–ò–¢–ï–¢ 2: –£–õ–£–ß–®–ï–ù–ù–ê–Ø –ü–û–ö–£–ü–ö–ê –° –î–ò–í–ï–†–°–ò–§–ò–ö–ê–¶–ò–ï–ô
            if (
                len(current_portfolio) < self.max_positions
                and available_balance >= self.min_order + self.reserve_cash
            ):
                buy_power = available_balance - self.reserve_cash

                # –ê–ù–ê–õ–ò–ó –¢–ï–ö–£–©–ï–ô –î–ò–í–ï–†–°–ò–§–ò–ö–ê–¶–ò–ò
                current_categories = self.analyze_portfolio_diversification(
                    current_portfolio, tickers
                )

                # –ü–û–ò–°–ö –õ–£–ß–®–ò–• –í–û–ó–ú–û–ñ–ù–û–°–¢–ï–ô –° –£–ß–ï–¢–û–ú –î–ò–í–ï–†–°–ò–§–ò–ö–ê–¶–ò–ò
                best_opportunities = self.find_diversified_opportunities(
                    tickers, current_portfolio, current_categories
                )

                bought_count = 0
                for symbol, score, price, category in best_opportunities:
                    if (
                        buy_power >= self.min_order
                        and bought_count < 2
                        and score > Decimal("1")
                    ):
                        amount_to_spend = min(self.position_size, buy_power)

                        if self.execute_buy_order(symbol, amount_to_spend, price):
                            bought_count += 1
                            buy_power -= amount_to_spend
                            available_balance = self.get_usdt_balance()
                            buy_power = available_balance - self.reserve_cash

                if bought_count == 0 and best_opportunities:
                    logger.info(
                        "‚ÑπÔ∏è –ù–µ –∫—É–ø–ª–µ–Ω–æ –ø–æ–∑–∏—Ü–∏–π –ø–æ—Å–ª–µ –¥–∏–≤–µ—Ä—Å–∏—Ñ–∏—Ü–∏—Ä–æ–≤–∞–Ω–Ω–æ–≥–æ –æ—Ç–±–æ—Ä–∞"
                    )

            return True

        except Exception as e:
            logger.error(f"‚ùå –û—à–∏–±–∫–∞ —É–ª—É—á—à–µ–Ω–Ω–æ–π —Ä–µ–±–∞–ª–∞–Ω—Å–∏—Ä–æ–≤–∫–∏: {e}")
            return False

    def run_optimized(self):
        """–û–ø—Ç–∏–º–∏–∑–∏—Ä–æ–≤–∞–Ω–Ω—ã–π –æ—Å–Ω–æ–≤–Ω–æ–π —Ü–∏–∫–ª —Å —É–ª—É—á—à–µ–Ω–Ω—ã–º –ª–æ–≥–∏—Ä–æ–≤–∞–Ω–∏–µ–º"""
        logger.info("üöÄ –ó–∞–ø—É—Å–∫ –û–ü–¢–ò–ú–ò–ó–ò–†–û–í–ê–ù–ù–û–ì–û —Å–ø–æ—Ç-–±–æ—Ç–∞ Bybit")
        logger.info(f"üíº –ö–∞–ø–∏—Ç–∞–ª: {self.total_capital} USDT")
        logger.info(f"üéØ –¶–µ–ª–∏: TP={self.take_profit} | SL={self.stop_loss}")
        logger.info(f"‚è±Ô∏è  –ò–Ω—Ç–µ—Ä–≤–∞–ª: 15 —Å–µ–∫—É–Ω–¥")
        logger.info(f"üìä –°—Ç–∞—Ç—É—Å –ø–æ—Ä—Ç—Ñ–µ–ª—è –±—É–¥–µ—Ç –æ–±–Ω–æ–≤–ª—è—Ç—å—Å—è –∫–∞–∂–¥—É—é –º–∏–Ω—É—Ç—É")

        iteration = 0
        error_count = 0
        max_errors = 5

        while True:
            try:
                iteration += 1

                if not self.db_conn or self.db_conn.closed:
                    self.db_conn = self.init_db()

                success = self.enhanced_rebalance(iteration)

                if success:
                    error_count = 0
                    if iteration % 40 == 0:
                        logger.info(f"üìà –ü—Ä–æ–≥—Ä–µ—Å—Å: –∏—Ç–µ—Ä–∞—Ü–∏—è #{iteration}")
                else:
                    error_count += 1
                    if error_count >= max_errors:
                        logger.error(
                            "üö® –ü—Ä–µ–≤—ã—à–µ–Ω–æ –º–∞–∫—Å–∏–º–∞–ª—å–Ω–æ–µ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –æ—à–∏–±–æ–∫, –ø–∞—É–∑–∞ 60 —Å–µ–∫—É–Ω–¥"
                        )
                        time.sleep(60)
                        error_count = 0

                time.sleep(15)

            except KeyboardInterrupt:
                logger.info("\n‚èπÔ∏è –û—Å—Ç–∞–Ω–æ–≤–∫–∞ –±–æ—Ç–∞ –ø–æ –∑–∞–ø—Ä–æ—Å—É –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è...")
                break
            except Exception as e:
                logger.error(f"‚ùå –ö—Ä–∏—Ç–∏—á–µ—Å–∫–∞—è –æ—à–∏–±–∫–∞ –≤ –æ—Å–Ω–æ–≤–Ω–æ–º —Ü–∏–∫–ª–µ: {e}")
                error_count += 1
                time.sleep(30)


if __name__ == "__main__":
    required_env_vars = ["BYBIT_API_KEY", "BYBIT_API_SECRET"]
    missing_vars = [var for var in required_env_vars if not os.getenv(var)]

    if missing_vars:
        print(
            f"‚ùå –û—Ç—Å—É—Ç—Å—Ç–≤—É—é—Ç –æ–±—è–∑–∞—Ç–µ–ª—å–Ω—ã–µ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã–µ –æ–∫—Ä—É–∂–µ–Ω–∏—è: {', '.join(missing_vars)}"
        )
        exit(1)

    bot = BybitSpotBot()

    try:
        bot.run_optimized()
    except KeyboardInterrupt:
        logger.info("\n‚èπÔ∏è –û—Å—Ç–∞–Ω–æ–≤–∫–∞ –±–æ—Ç–∞...")
    finally:
        if bot.db_conn:
            bot.db_conn.close()
